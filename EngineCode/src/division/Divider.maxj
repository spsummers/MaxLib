package division;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.Optimization;
import com.maxeler.maxcompiler.v2.kernelcompiler.op_management.MathOps;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Bitops;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.FloatingPoint;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEFix;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEFix.SignMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEFloat;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar.Radix;

public class Divider extends KernelLib{

	private boolean signed = true;
	private static boolean simWatch = false;
	private static boolean verbose = false;
	private String simWatchPrefix;
	private double numerator = 1;
	private static double DSPPipelineFactor = 1.;
	private static boolean lowLatency = false;

	public Divider(Kernel owner){
		super(owner);
	}

	public static DFEVar divInt18_1BRAM_1DSP(DFEVar x){
		Divider div = new Divider(x.getKernel());
		if(simWatch)
			div.setSimWatch("div");
		return div.reducedLUTDivide(x, 11, 7, 25, 25);
	}

	public static DFEVar divInt18_1BRAM_2DSP(DFEVar x){
		Divider div = new Divider(x.getKernel());
		if(simWatch)
			div.setSimWatch("div");
		return div.reducedLUTDivide(x, 11, 7, 35, 35);
	}

	public DFEVar reducedLUTDivide(DFEVar x, int nHighBits, int nLowBits, int nInvBits, int nOutputBits){
		optimization.pushEnableBitGrowth(true);
		int nInBits = x.getType().getTotalBits();
		DFEVar positive = x > 0;
		if(lowLatency)
			optimization.pushPipeliningFactor(0);
		DFEVar absx = KernelMath.abs(x.cast(dfeRawBits(nInBits)).cast(dfeInt(nInBits))).cast(dfeUInt(nInBits));
		if(lowLatency){
			absx = optimization.pipeline(absx);
			optimization.popPipeliningFactor();
		}
		if(nLowBits + nHighBits != absx.getType().getTotalBits())
			System.err.println("Incompatible numbers of bits");
		if(lowLatency)
			optimization.pushPipeliningFactor(0);
		DFEVar leading1 = Bitops.onehotDecode(Bitops.leading1Detect(absx));
		if(lowLatency){
			optimization.popPipeliningFactor();
			//leading1 = optimization.pipeline(leading1);
		}
		DFEVar nShift = (nInBits - 1 - leading1).cast(dfeUInt(leading1.getType().getTotalBits()));

		if(lowLatency)
			optimization.pushPipeliningFactor(0);
		DFEVar xShifted = absx.shiftLeft(nShift);//.cast(dfeUInt(nShift.getType().getTotalBits()-1)));
		if(lowLatency){
			//xShifted = optimization.pipeline(xShifted);
			optimization.popPipeliningFactor();
		}
		DFEVar xL = xShifted.slice(0, nLowBits).cast(dfeUInt(nLowBits));
		DFEVar xH = (xShifted.slice(nLowBits, nHighBits) # constant.var(dfeRawBits(nLowBits), 0)).cast(dfeUInt(nInBits));
		DFEVar xH0 = xShifted.slice(nLowBits, nHighBits - 1);
		// xH > xL so truncate with no underflow to maintain precision
		optimization.pushFixOpMode(Optimization.bitSizeExact(nInBits), Optimization.offsetExact(1), MathOps.SUB);
		DFEVar xDiff = xH - xL;
		optimization.popFixOpMode(MathOps.SUB);

		double maxVal = 1/Math.pow(Math.pow(2, nInBits-1), 2);
		DFEType txInv = dfeFixMax(nInvBits, maxVal, SignMode.TWOSCOMPLEMENT);
		int nLUTBits = (int) Math.pow(2, xH0.getType().getTotalBits());
		Memory<DFEVar> xHInvLUT = mem.alloc(txInv, nLUTBits);
		DFEVar xInvSq = xHInvLUT.read(xH0);
		optimization.pushFixOpMode(Optimization.bitSizeExact(nOutputBits), Optimization.offsetNoOverflow(), MathOps.MUL);
		optimization.pushPipeliningFactor(DSPPipelineFactor);
		DFEVar xInv = xDiff * xInvSq;
		optimization.popPipeliningFactor();
		optimization.popFixOpMode(MathOps.MUL);
		DFEVar xInvBiggerContainer = constant.var(dfeRawBits(nInBits), 0) # xInv;
		//if(lowLatency)
		//	optimization.pushPipeliningFactor(0);
		DFEVar xInvShift = xInvBiggerContainer.shiftLeft(nShift + 2);//nShift.cast(dfeUInt(nShift.getType().getTotalBits()-1)) + 2);
		/*if(lowLatency){
			xInvShift = optimization.pipeline(xInvShift);
			optimization.popPipeliningFactor();
		}*/
		DFEVar xInvShiftTrunc = xInvShift.slice(nInBits, nOutputBits).cast(dfeUInt(nOutputBits));
		optimization.popEnableBitGrowth();

		double xInvVals[] = new double[nLUTBits];
		for(int n = 0; n < nLUTBits; n++){
			double xVal = (n + Math.pow(2, nHighBits - 1)) * Math.pow(2, nLowBits);
			xInvVals[n] = 1 / (xVal * xVal);
			//System.out.println(xVal + ", " + xInvVals[n]);
		}
		xHInvLUT.setContents(xInvVals);

		optimization.pushEnableBitGrowth(false);
		xInvShiftTrunc = positive ? xInvShiftTrunc : - xInvShiftTrunc;
		optimization.popEnableBitGrowth();
		if(simWatch){
			x.simWatch(simWatchPrefix+"_x");
			nShift.simWatch(simWatchPrefix+"_nShift");
			xH.simWatch(simWatchPrefix+"_xHigh");
			xH0.simWatch(simWatchPrefix+"_xHaddr");
			xL.simWatch(simWatchPrefix+"_xLow");
			xDiff.simWatch(simWatchPrefix+"_xDiff");
			xInvSq.simWatch(simWatchPrefix+"_xHighInvSquared");
			xInv.simWatch(simWatchPrefix+"_xInv");
			xInvShift.simWatch(simWatchPrefix+"_invX");
			xInvShift.simWatch(simWatchPrefix+"_invXShifted", Radix.BINARY);
		}
		return xInvShiftTrunc;
	}

	public DFEVar reducedLUTDivideIgnore(DFEVar x, int nHighBits, int nLowBits, int nInvBits, int nOutputBits, int ignoreBits){
		optimization.pushEnableBitGrowth(true);
		int nInBits = x.getType().getTotalBits();
		DFEVar positive = x > 0;
		if(lowLatency)
			optimization.pushPipeliningFactor(0);
		DFEVar absx = KernelMath.abs(x.cast(dfeRawBits(nInBits)).cast(dfeInt(nInBits))).cast(dfeUInt(nInBits));
		if(lowLatency){
			absx = optimization.pipeline(absx);
			optimization.popPipeliningFactor();
		}
		if(nLowBits + nHighBits != absx.getType().getTotalBits())
			System.err.println("Incompatible numbers of bits");
		if(lowLatency)
			optimization.pushPipeliningFactor(0);
		DFEVar leading1 = Bitops.onehotDecode(Bitops.leading1Detect(absx.slice(ignoreBits, nInBits-ignoreBits).cast(dfeUInt(nInBits-ignoreBits))));
		if(lowLatency){
			optimization.popPipeliningFactor();
			//leading1 = optimization.pipeline(leading1);
		}
		DFEVar nShift = (nInBits - ignoreBits - 1 - leading1).cast(dfeUInt(leading1.getType().getTotalBits()));
		if(lowLatency)
			optimization.pushPipeliningFactor(0);
		DFEVar xShifted = absx.shiftLeft(nShift);//.cast(dfeUInt(nShift.getType().getTotalBits()-1)));
		if(lowLatency){
			//xShifted = optimization.pipeline(xShifted);
			optimization.popPipeliningFactor();
		}
		DFEVar xL = xShifted.slice(0, nLowBits).cast(dfeUInt(nLowBits));
		DFEVar xH = (xShifted.slice(nLowBits, nHighBits) # constant.var(dfeRawBits(nLowBits), 0)).cast(dfeUInt(nInBits));
		DFEVar xH0 = xShifted.slice(nLowBits, nHighBits - 1);
		// xH > xL so truncate with no underflow to maintain precision
		//optimization.pushFixOpMode(Optimization.bitSizeExact(nInBits), Optimization.offsetExact(1), MathOps.SUB);
		DFEVar xDiff = xH - xL;
		//optimization.popFixOpMode(MathOps.SUB);

		double maxVal = 1/Math.pow(Math.pow(2, nInBits-1), 2);
		DFEType txInvSq = dfeFixMax(nInvBits, maxVal, SignMode.TWOSCOMPLEMENT);
		System.out.println("tXInvSq = " + txInvSq);
		int nLUTBits = (int) Math.pow(2, xH0.getType().getTotalBits());
		Memory<DFEVar> xHInvLUT = mem.alloc(txInvSq, nLUTBits);
		DFEVar xInvSq = xHInvLUT.read(xH0);
		optimization.pushFixOpMode(Optimization.bitSizeExact(nOutputBits), Optimization.offsetNoOverflow(), MathOps.MUL);
		optimization.pushPipeliningFactor(DSPPipelineFactor);
		DFEVar xInv = xDiff * xInvSq;
		optimization.popPipeliningFactor();
		optimization.popFixOpMode(MathOps.MUL);
		int maxShift = nInBits - ignoreBits - 1;
		DFEVar rShift = (maxShift - nShift).cast(dfeUInt(leading1.getType().getTotalBits()));
		//if(lowLatency)
		//	optimization.pushPipeliningFactor(0);
		DFEVar xInvShift = xInv.shiftRight(rShift);//nShift.cast(dfeUInt(nShift.getType().getTotalBits()-1)) + 2);
		/*if(lowLatency){
			xInvShift = optimization.pipeline(xInvShift);
			optimization.popPipeliningFactor();
		}*/
		optimization.popEnableBitGrowth();

		double xInvVals[] = new double[nLUTBits];
		for(int n = 0; n < nLUTBits; n++){
			double xVal = (n + Math.pow(2, nHighBits - 1)) * Math.pow(2, nLowBits);
			xInvVals[n] = 1 / (xVal * xVal);
		}
		xHInvLUT.setContents(xInvVals);

		optimization.pushEnableBitGrowth(false);
		xInvShift = positive ? xInvShift : - xInvShift;
		optimization.popEnableBitGrowth();
		if(simWatch){
			x.simWatch(simWatchPrefix+"_x");
			toInt(x).simWatch(simWatchPrefix+"_xBin");
			nShift.simWatch(simWatchPrefix+"_nShift");
			xH.simWatch(simWatchPrefix+"_xHigh");
			xH0.simWatch(simWatchPrefix+"_xHaddr");
			xL.simWatch(simWatchPrefix+"_xLow");
			toInt(xDiff).simWatch(simWatchPrefix+"_xDiff");
			toInt(xInvSq).simWatch(simWatchPrefix+"_xHighInvSquared");
			toInt(xInv).simWatch(simWatchPrefix+"_xInv");
			toInt(xInvShift).simWatch(simWatchPrefix+"_invX");
			//xInvShift.simWatch(simWatchPrefix+"_invXShifted", Radix.BINARY);
		}
		return xInvShift;
	}

	/**
	 * Reduced LUT division for floating point DFEVars
	 * Similar to fixed point implementation
	 * but skips pre & post shift due to floating point renormalisation
	 * @param x The number to invert
	 * @return 1/x
	 */
	public static DFEVar reducedLUTDivideFloat(DFEVar x, int nHighBits){
		Kernel k = x.getKernel();

		DFEFloat xType = (DFEFloat) x.getType();
		int nLowBits = xType.getMantissaBits() - nHighBits;

		DFEVar xMan = FloatingPoint.getMantissa(x);
		DFEVar xExp = FloatingPoint.getExponentBits(x).cast(dfeUInt(xType.getExponentBits()));
		DFEVar xSign = FloatingPoint.getSignBit(x);

		DFEVar xL = xMan.slice(0, nLowBits).cast(dfeUInt(nLowBits));
		DFEVar xH = (xMan.slice(nLowBits, nHighBits) # k.constant.var(dfeRawBits(nLowBits), 0)).cast(dfeUInt(xType.getMantissaBits()));
		DFEVar xH0 = xMan.slice(nLowBits, nHighBits - 1);

		k.optimization.pushEnableBitGrowth(true);
		DFEVar xDiff = xH - xL;
		k.optimization.popEnableBitGrowth();

		// Fill the look up table with 1 / xH^2 values, assuming the implicit 1 at MSB
		double maxVal = 1/Math.pow(Math.pow(2, xType.getMantissaBits() - 1), 2); // = 1/min(xH)^2
		DFEType txInvSq = dfeFixMax(xType.getMantissaBits() + 1, maxVal, SignMode.TWOSCOMPLEMENT);
		System.out.println("tXInvSq = " + txInvSq);
		int nLUTBits = (int) Math.pow(2, xH0.getType().getTotalBits());

		Memory<DFEVar> xHInvLUT = k.mem.alloc(txInvSq, nLUTBits);
		double xInvVals[] = new double[nLUTBits];
		for(int n = 0; n < nLUTBits; n++){
			double xVal = (n + Math.pow(2, nHighBits - 1)) * Math.pow(2, nLowBits);
			xInvVals[n] = 1 / (xVal * xVal);
		}
		xHInvLUT.setContents(xInvVals);

		DFEVar xInvSq = xHInvLUT.read(xH0);
		k.optimization.pushEnableBitGrowth(true);
		// Because we left xDiff, xInvSq as twos complement, but they are really unsigned
		// we have some leading 0s to remove to retain best precision
		k.optimization.pushFixOpMode(Optimization.bitSizeExact(xType.getMantissaBits() + 3), Optimization.offsetNoOverflow(), MathOps.MUL);
		DFEVar xInv = xDiff * xInvSq;
		k.optimization.popFixOpMode(MathOps.MUL);
		k.optimization.popEnableBitGrowth();

		int xInvBits = xInv.getType().getTotalBits();
		DFEVar xInvCast = xInv.cast(dfeRawBits(xInvBits)).slice(xInvBits - xType.getMantissaBits() - 2, xType.getMantissaBits());

		// Set the new exponent
		// N.B. here we manipulate the biased exponent
		k.optimization.pushFixOpMode(Optimization.bitSizeExact(xType.getExponentBits()), Optimization.offsetExact(0), MathOps.SUB);
		DFEVar newXExp = (2 * xType.getExponentBias() -1 ) - xExp;
		// If mantissa == 0 (i.e. x is power of 2) we must add 1 back
		//newXExp += (xMan === 0) ? 1 : 0; // Find the conditional arithmetic enable for this
		newXExp = xMan === 0 ? newXExp + 1 : newXExp;
 		k.optimization.popFixOpMode(MathOps.SUB);

		// Pack the sign, exponent and mantissa, slicing away the implicit MSB = 1
		DFEVar result = (xSign # newXExp # xInvCast.slice(0, xType.getMantissaBits() - 1)).cast(xType);
		return result;
	}

    public DFEVar LUTdivide(DFEVar x, int nInvBits){
        int nXBits = x.getType().getTotalBits();
        int nMem = (int) Math.pow(2, nXBits);
        double denominators[] = new double[nMem];
        double maxVal = 0;
        if(this.signed){
        	maxVal = (1 - Math.pow(2, -(nInvBits-1))) * numerator;
        }else{
        	maxVal = (1 - Math.pow(2, -nInvBits)) * numerator;
        }
        for(int n = 0; n < nMem; n++){
            double value = maxVal;
            if(n == 0){
                denominators[n] = 1 - Math.pow(2, -(nInvBits-1));
            }else if((n < Math.pow(2, nXBits - 1)) | this.signed == false ){ // Then val is positive part of signed, or unsigned
            	value = n;
                denominators[n] = numerator / value;
                if(n == 1)
                    denominators[n] -= Math.pow(2, -(nInvBits-1));
            }else{ // Then val is negative
                value = n - nMem;
                denominators[n] = numerator/value;
            }
            if(denominators[n] >  maxVal || denominators[n] < -maxVal){
                System.out.println("n="+n+", |1/"+value+"| = " + Math.abs(denominators[n]) + " > "+maxVal);
            }
        }
        int nIntegerBits = (int) Math.ceil(Math.log(numerator) / Math.log(2)); // Sufficient bits to store constant numerator
        SignMode sign = SignMode.TWOSCOMPLEMENT;
        if(this.signed == false){
        	sign = SignMode.UNSIGNED;
        }
        Memory<DFEVar> divTable = mem.alloc(dfeFix(nIntegerBits, nInvBits - nIntegerBits- 1, sign), nMem);
        divTable.setContents(denominators);
        return divTable.read(x.pack());
    }


	public void setSigned(boolean signed){
		this.signed = signed;
	}

	public void setSimWatch(String prefix){
		boolean oldWatch = simWatch;
		simWatch = true;
		this.simWatchPrefix = prefix;
		simWatch = oldWatch;
	}

	public void setConstantNumerator(double value){
		this.numerator = value;
	}

	public static void setWatch(boolean watch){
		simWatch = watch;
	}

	public static void setDSPPipelineFactor(double f){
		DSPPipelineFactor = f;
	}

	public static void setLowLatency(boolean l){
		lowLatency = l;
	}

	public static DFEVar toInt(DFEVar x){
		int nBits = x.getType().getTotalBits();
		DFEType t = isSigned(x) ? dfeInt(nBits) : dfeUInt(nBits);
		return x.cast(dfeRawBits(nBits)).cast(t);
	}

	private static boolean isSigned(DFEVar x){
		DFEFix t = (DFEFix) x.getType();
		return t.getSignMode() == SignMode.TWOSCOMPLEMENT;
	}
}
