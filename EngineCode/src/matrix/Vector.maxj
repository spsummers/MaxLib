package matrix;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.KernelObject;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStruct;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType.StructFieldType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;

public class Vector extends Matrix{

	public enum Shape{
		ROW, COL;
	}

	private Shape shape = Shape.COL;

	public Vector(Vector other){
		super(other.data(0, 0).getKernel());
		this.data(other.data);
		this.shape = other.shape;
	}
	public Vector(DFEVector<DFEVar> data){
		super(data.get(0).getKernel());
		DFEVar[][] matData = new DFEVar[data.getSize()][1];
		for(int i = 0; i < data.getSize(); i++)
			matData[i][0] = data.get(i);
		this.data(matData);
	}

	public Vector(DFEVar[] data){
		super(data[0].getKernel());
		DFEVar[][] matData = new DFEVar[data.length][1];
		for(int i = 0; i < data.length; i++)
			matData[i][0] = data[i];
		this.data(matData);
	}

	public Vector(DFEVar[][] data){
		super(data[0][0].getKernel());
		if(data.length != 1 && data[0].length != 1){
			System.err.println("Vector: Trying to construct a Vector from 2D array data with 2 non-unity axes");
			this.data(null);
		}else{
			if(data.length == 1){
				shape = Shape.ROW;
			}else if(data[0].length == 1){
				shape = Shape.COL;
			}
			this.data(data);
		}
	}

	public Vector(Kernel owner){
		super(owner);
	}

	public DFEVar data(int i){
		return this.data()[i][0];
	}

	public Shape shape(){ return shape; }

	public void shape(Shape shape){
		if(shape != this.shape){
			DFEVar[][] newData = new DFEVar[this.nCols()][this.nRows()];
			for(int i = 0; i < nCols(); i++)
				for(int j = 0; j < nRows(); j++)
					newData[i][j] = this.data(j, i);
			this.data = newData;
			this.shape = shape;
		}
	}

	public Vector add(Vector rhs){
		return (Vector) ((LinAlg)this).add(rhs);
	}

	public Vector sub(Vector rhs){
		return (Vector) ((LinAlg) this).sub(rhs);
	}

	public KernelObject packForIO(){
		KernelObject packed;
		Vector v = new Vector(this);
		v.shape(Shape.COL);
		if(sameType()){
			DFEVectorType<DFEVar> tPacked = new DFEVectorType<DFEVar>(data(0, 0).getType(), v.nCols());
			packed = tPacked.newInstance(getKernel());
			for(int i = 0; i < v.nRows(); i++)
				((DFEVector<DFEVar>) packed).get(i) <== v.data(i, 0);
		}else{
			StructFieldType[] sfts = new StructFieldType[v.nCols()];
			for(int i = 0; i < v.nRows(); i++)
				sfts[i] = new StructFieldType(""+i, v.data(i, 0).getType());
			DFEStructType tPacked = new DFEStructType(sfts);
			packed = tPacked.newInstance(getKernel());
			for(int i = 0; i < v.nRows(); i++)
				((DFEStruct) packed).get(""+i) <== v.data(i, 0);
		}
		return packed;
	}

	private boolean sameType(){
		boolean same = true;
		Vector v = new Vector(this);
		v.shape(Shape.COL);
		DFEType T = v.data(0, 0).getType();
		for(int i = 0; i < v.nRows(); i++)
			same = v.data(i, 0).getType() == T;
		return same;
	}

}
